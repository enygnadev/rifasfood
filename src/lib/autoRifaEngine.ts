import { initializeApp, getApp } from "firebase/app";
import { getFirestore, doc, getDoc, collection, query, where, getDocs, addDoc, updateDoc, deleteDoc, serverTimestamp, Timestamp } from "firebase/firestore";

// Garantir que Firebase está inicializado
function initFirebase() {
  try {
    return getApp();
  } catch {
    const firebaseConfig = {
      apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
      authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
      projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
      storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
      messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
      appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,
    };
    return initializeApp(firebaseConfig);
  }
}

initFirebase();

export async function getAutoTemplatesFromConfig(): Promise<any[]> {
  try {
    const db = getFirestore();
    const docRef = doc(db, "config", "autoTemplates");
    const docSnap = await getDoc(docRef);
    if (docSnap.exists()) {
      return docSnap.data()?.templates || [];
    }
    return [];
  } catch (e) {
    console.error("Erro ao buscar autoTemplates:", e);
    return [];
  }
}

export function getBadges(rifa: any): string[] {
  const badges: string[] = [];
  const percentComplete = rifa.meta > 0 ? ((rifa.vendidos || 0) / rifa.meta) * 100 : 0;
  const now = Date.now();
  const createdAt = rifa.createdAt?.toDate?.()?.getTime?.() || rifa.createdAt?._seconds * 1000 || 0;
  const timerExpiresAt = rifa.timerExpiresAt?.toDate?.()?.getTime?.() || rifa.timerExpiresAt?._seconds * 1000 || 0;

  if (rifa.status === "contagem" || (timerExpiresAt > 0 && timerExpiresAt > now)) {
    badges.push("ultimos-momentos");
  }

  if (percentComplete >= 80 && rifa.status === "aberta") {
    badges.push("quase-esgotada");
  }

  if (now - createdAt < 30 * 60 * 1000) {
    badges.push("nova-rodada");
  }

  if ((rifa.comprasRecentes || 0) > 5) {
    badges.push("popular");
  }

  return badges;
}

export async function isAutoRifaEnabled(): Promise<boolean> {
  const db = getFirestore();
  try {
    const configDocRef = doc(db, "config", "autoRifa");
    const configDocSnap = await getDoc(configDocRef);
    return configDocSnap.exists() && configDocSnap.data()?.enabled === true;
  } catch {
    return false;
  }
}

export async function createRifaForProduct(product: any): Promise<string | null> {
  const db = getFirestore();
  try {
    const rifaData = {
      nome: `${product.emoji} ${product.nome}`,
      categoria: product.categoria,
      meta: product.meta,
      vendidos: 0,
      valorPorNumero: product.valorPorNumero,
      status: "ativa",
      productId: product.id,
      autoGenerated: true,
      imagem: product.imagem,
      descricao: product.descricao,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp(),
      numerosComprados: [],
      comprasRecentes: 0,
      lastActivityAt: serverTimestamp(),
    };
    const rifasRef = collection(db, "rifas");
    const docRef = await addDoc(rifasRef, rifaData);
    console.log(`[AutoRifa] Created new rifa for ${product.nome}: ${docRef.id}`);
    return docRef.id;
  } catch (err) {
    console.error(`[AutoRifa] Error creating rifa for ${product.nome}:`, err);
    return null;
  }
}

export async function ensureAllProductsHaveActiveRifas(): Promise<void> {
  const db = getFirestore();

  const enabled = await isAutoRifaEnabled();
  if (!enabled) return;

  try {
    // Buscar apenas rifas ATIVAS (não em contagem, pois essas vão ser sorteadas)
    const rifasRef = collection(db, "rifas");
    const q = query(rifasRef, where("status", "in", ["ativa", "aberta"]));
    const activeSnap = await getDocs(q);
    const activeProductIds = new Set<string>();

    activeSnap.forEach((docSnap) => {
      const data = docSnap.data();
      if (data.productId) {
        activeProductIds.add(data.productId);
      }
    });

    const products = await getAutoTemplatesFromConfig();
    for (const product of products) {
      if (!activeProductIds.has(product.id)) {
        await createRifaForProduct(product);
        console.log(`[AutoRifa] Criada rifa para produto ${product.id} (${product.nome}) pois não havia rifa ativa`);
      }
    }
  } catch (err) {
    console.error("[AutoRifa] Error ensuring products have rifas:", err);
  }
}

export async function checkAndBoostStagnantRifas(): Promise<void> {
  const db = getFirestore();

  const enabled = await isAutoRifaEnabled();
  if (!enabled) return;

  try {
    const rifasRef = collection(db, "rifas");
    const q = query(rifasRef, where("status", "==", "ativa"));
    const rifasSnap = await getDocs(q);
    const now = Date.now();

    for (const rifaDoc of rifasSnap.docs) {
      const rifa = rifaDoc.data();
      const percentComplete = rifa.meta > 0 ? ((rifa.vendidos || 0) / rifa.meta) * 100 : 0;
      const lastActivity = rifa.lastActivityAt?.toDate?.()?.getTime?.() || rifa.updatedAt?.toDate?.()?.getTime?.() || 0;
      const stagnantMinutes = (now - lastActivity) / (1000 * 60);

      if (percentComplete >= 80 && stagnantMinutes >= 5) {
        const remaining = rifa.meta - (rifa.vendidos || 0);
        const boost = Math.min(remaining, Math.ceil(remaining * 0.3));

        if (boost > 0) {
          const existingNumeros = rifa.numerosComprados || [];
          const startNum = (rifa.vendidos || 0) + 1;
          const syntheticEntries = Array.from({ length: boost }, (_, i) => ({
            numero: startNum + i,
            userId: "system-boost",
            synthetic: true,
            createdAt: new Date(),
          }));

          const rifaRef = doc(db, "rifas", rifaDoc.id);
          await updateDoc(rifaRef, {
            vendidos: (rifa.vendidos || 0) + boost,
            numerosComprados: [...existingNumeros, ...syntheticEntries],
            lastActivityAt: serverTimestamp(),
            updatedAt: serverTimestamp(),
          });
          console.log(`[AutoRifa] Boosted rifa ${rifaDoc.id} by ${boost} numbers with synthetic entries`);
        }
      }
    }
  } catch (err) {
    console.error("[AutoRifa] Error boosting stagnant rifas:", err);
  }
}

export async function checkGoalReachedRifas(): Promise<{ rifasMovidas: number; rifasCriadas: number }> {
  const db = getFirestore();
  let rifasMovidas = 0;
  let rifasCriadas = 0;

  const enabled = await isAutoRifaEnabled();
  console.log(`[AutoRifa] checkGoalReachedRifas - Motor enabled: ${enabled}`);
  if (!enabled) return { rifasMovidas: 0, rifasCriadas: 0 };

  try {
    // Buscar rifas ativas que ainda não estão em contagem
    const rifasRef = collection(db, "rifas");
    const q = query(rifasRef, where("status", "in", ["ativa", "aberta"]));
    const rifasSnap = await getDocs(q);
    
    console.log(`[AutoRifa] Encontradas ${rifasSnap.size} rifas ativas para verificar metas`);

    for (const rifaDoc of rifasSnap.docs) {
      const rifa = rifaDoc.data();
      const rifaId = rifaDoc.id;
      
      console.log(`[AutoRifa] Verificando rifa ${rifaId}: vendidos=${rifa.vendidos || 0}, meta=${rifa.meta || 100}`);

      // Verificar se a rifa atingiu a meta
      if ((rifa.vendidos || 0) >= (rifa.meta || 100)) {
        console.log(`[AutoRifa] Rifa ${rifaId} (${rifa.nome}) atingiu a meta! ${rifa.vendidos}/${rifa.meta}`);
        
        // 1. Mover para "contagem" (Prestes a Sortear) com timer de 10 minutos
        const timerExpiresAt = new Date(Date.now() + 10 * 60 * 1000).toISOString();
        
        const rifaRef = doc(db, "rifas", rifaId);
        await updateDoc(rifaRef, {
          status: "contagem",
          timerExpiresAt,
          updatedAt: serverTimestamp(),
        });
        rifasMovidas++;
        console.log(`[AutoRifa] Rifa ${rifaId} movida para 'contagem'. Timer: 10 min`);

        // 2. Criar nova rifa igual para manter o loop
        try {
          const novaRifaData = {
            nome: rifa.nome,
            categoria: rifa.categoria || "outros",
            meta: rifa.meta || 100,
            vendidos: 0,
            valorPorNumero: rifa.valorPorNumero || rifa.valor || 10,
            imagem: rifa.imagem,
            descricao: rifa.descricao,
            productId: rifa.productId,
            status: "ativa",
            autoGenerated: true,
            previousRifaId: rifaId,
            numerosComprados: [],
            comprasRecentes: 0,
            createdAt: serverTimestamp(),
            updatedAt: serverTimestamp(),
            lastActivityAt: serverTimestamp(),
          };
          
          const novaRifaRef = await addDoc(collection(db, "rifas"), novaRifaData);
          rifasCriadas++;
          console.log(`[AutoRifa] Nova rifa criada: ${novaRifaRef.id} (clone de ${rifaId} - ${rifa.nome})`);
        } catch (e) {
          console.error(`[AutoRifa] Erro ao criar nova rifa para ${rifaId}:`, e);
        }
      }
    }
  } catch (err) {
    console.error("[AutoRifa] Erro ao verificar metas atingidas:", err);
  }

  return { rifasMovidas, rifasCriadas };
}

export async function processExpiredCountdowns(): Promise<{ processed: number; winners: any[] }> {
  const db = getFirestore();

  const enabled = await isAutoRifaEnabled();
  if (!enabled) return { processed: 0, winners: [] };

  const winnersNotified: any[] = [];

  try {
    const now = new Date();
    
    // Buscar rifas em contagem com timer expirado usando Client SDK
    const rifasRef = collection(db, "rifas");
    const qRifas = query(rifasRef, where("status", "==", "contagem"));
    const rifasSnap = await getDocs(qRifas);
    
    // Filtrar manualmente as que têm timer expirado
    const expiredRifas = rifasSnap.docs.filter(rifaDoc => {
      const rifa = rifaDoc.data();
      const timerExpiresAt = rifa.timerExpiresAt?.toDate?.() || 
        (typeof rifa.timerExpiresAt === 'string' ? new Date(rifa.timerExpiresAt) : null);
      return timerExpiresAt && timerExpiresAt <= now;
    });

    for (const rifaDoc of expiredRifas) {
      const rifa = rifaDoc.data();
      const rifaId = rifaDoc.id;

      // Buscar todas as compras pagas desta rifa
      const comprasRef = collection(db, "compras");
      const qCompras = query(comprasRef, where("rifaId", "==", rifaId), where("status", "==", "pago"));
      const comprasSnap = await getDocs(qCompras);

      // Mapear números para donos
      const ownerMap = new Map<number, { userId: string; email?: string; phone?: string; purchaseId: string }>();
      const participantIds = new Set<string>();
      let maxNumber = 0;

      comprasSnap.forEach((compraDoc) => {
        const compra = compraDoc.data();
        participantIds.add(compra.userId);
        (compra.numeros || []).forEach((n: number) => {
          ownerMap.set(n, {
            userId: compra.userId,
            email: compra.email,
            phone: compra.phone,
            purchaseId: compraDoc.id,
          });
          maxNumber = Math.max(maxNumber, n);
        });
      });

      let winner = null;
      let winningNumber = null;
      let seed = "";
      let winnerFullData = null;

      if (maxNumber > 0) {
        // Gerar seed auditável usando dados da rifa + timestamp
        seed = `${rifaId}-${rifa.timerExpiresAt || ''}-${Date.now()}-${rifa.vendidos || 0}`;
        const crypto = await import("crypto");
        const hash = crypto.createHash("sha256").update(seed).digest("hex");
        // Usar os primeiros 15 caracteres do hash para determinar o número
        const slice = hash.slice(0, 15);
        const num = parseInt(slice, 16);
        winningNumber = (num % maxNumber) + 1;
        winner = ownerMap.get(winningNumber) || null;

        // Buscar dados completos do usuário vencedor
        if (winner && winner.userId) {
          try {
            const userRef = doc(db, "users", winner.userId);
            const userSnap = await getDoc(userRef);
            if (userSnap.exists()) {
              const userData = userSnap.data();
              winnerFullData = {
                ...winner,
                name: userData?.name || userData?.displayName || "Anônimo",
                email: userData?.email || winner.email,
                phone: userData?.phone || winner.phone,
                photoURL: userData?.photoURL,
              };
            } else {
              winnerFullData = winner;
            }
          } catch (e) {
            console.error(`[AutoRifa] Erro ao buscar dados do usuário ${winner.userId}:`, e);
            winnerFullData = winner;
          }
        }
      }

      // Mover rifa para coleção sorteiosFinalizados
      const sorteioData = {
        ...rifa,
        rifaId, // ID original da rifa
        status: "finalizado",
        vencedor: winnerFullData ? {
          ...winnerFullData,
          winningNumber,
          seed,
          drawnAt: serverTimestamp(),
        } : null,
        winningNumber,
        seed,
        sortedAt: serverTimestamp(),
        totalParticipantes: participantIds.size,
        finalizadoEm: serverTimestamp(),
      };
      
      // Adicionar à coleção sorteiosFinalizados
      const sorteiosRef = collection(db, "sorteiosFinalizados");
      await addDoc(sorteiosRef, sorteioData);
      
      // Deletar da coleção rifas para não voltar aos componentes
      const rifaRef = doc(db, "rifas", rifaId);
      await deleteDoc(rifaRef);

      // Registrar no histórico também (backup)
      const historicoRef = collection(db, "historico");
      await addDoc(historicoRef, {
        rifaId,
        rifaNome: rifa.nome,
        descricao: rifa.descricao,
        winner: winnerFullData,
        winningNumber,
        seed,
        totalVendidos: rifa.vendidos,
        totalParticipantes: participantIds.size,
        sortedAt: serverTimestamp(),
      });

      console.log(`[AutoRifa] Sorteio finalizado - Rifa: ${rifaId}, Vencedor: ${winnerFullData?.userId || 'nenhum'}, Número: ${winningNumber}`);

      // Coletar tokens FCM de todos os participantes para notificação
      const allTokens: string[] = [];
      const winnerTokens: string[] = [];

      for (const uid of participantIds) {
        try {
          const userDocRef = doc(db, "users", uid);
          const userDoc = await getDoc(userDocRef);
          const userData = userDoc.data();
          if (userData?.fcmTokens?.length) {
            allTokens.push(...userData.fcmTokens);
            if (winner && winner.userId === uid) {
              winnerTokens.push(...userData.fcmTokens);
            }
          }
        } catch (e) {
          console.warn(`Erro ao buscar tokens do usuário ${uid}:`, e);
        }
      }

      // Criar registro de notificação pendente no Firestore para o vencedor
      if (winner) {
        const notificationsRef = collection(db, "notifications");
        await addDoc(notificationsRef, {
          type: "winner",
          rifaId,
          rifaNome: rifa.nome,
          userId: winner.userId,
          email: winner.email,
          phone: winner.phone,
          winningNumber,
          premio: rifa.premio,
          tokens: winnerTokens,
          allParticipantTokens: allTokens,
          status: "pending",
          createdAt: serverTimestamp(),
        });

        winnersNotified.push({
          rifaId,
          rifaNome: rifa.nome,
          winner,
          winningNumber,
        });
      }

      // Criar nova rodada automaticamente se for produto auto
      if (rifa.productId) {
        const templates = await getAutoTemplatesFromConfig();
        const product = templates.find((p) => p.id === rifa.productId);
        if (product) {
          await createRifaForProduct(product);
        }
      }
    }

    return { processed: expiredRifas.length, winners: winnersNotified };
  } catch (err) {
    console.error("[AutoRifa] Erro ao processar countdowns expirados:", err);
    return { processed: 0, winners: [] };
  }
}

export async function runAutoRifaCycle(): Promise<{ processed: boolean; message: string; details?: any }> {
  const enabled = await isAutoRifaEnabled();
  if (!enabled) {
    return { processed: false, message: "Auto-rifa is disabled" };
  }

  // 1. Garantir que todos os produtos têm rifas ativas
  await ensureAllProductsHaveActiveRifas();
  
  // 2. Verificar rifas que atingiram a meta e mover para contagem + criar nova
  const metaResult = await checkGoalReachedRifas();
  
  // 3. Boost em rifas estagnadas (opcional)
  await checkAndBoostStagnantRifas();
  
  // 4. Processar countdowns expirados e sortear
  const sorteioResult = await processExpiredCountdowns();

  const message = [
    `Auto-rifa cycle completed.`,
    metaResult.rifasMovidas > 0 ? `${metaResult.rifasMovidas} rifas movidas para contagem.` : null,
    metaResult.rifasCriadas > 0 ? `${metaResult.rifasCriadas} novas rifas criadas.` : null,
    sorteioResult.processed > 0 ? `${sorteioResult.processed} sorteios realizados.` : null,
  ].filter(Boolean).join(' ');

  return { 
    processed: true, 
    message,
    details: {
      metasAtingidas: metaResult,
      sorteios: sorteioResult,
    },
  };
}

// Função para enviar notificações pendentes via API
export async function sendPendingNotifications(): Promise<{ sent: number; errors: number }> {
  const db = getFirestore();
  let sent = 0;
  let errors = 0;

  try {
    const notificationsRef = collection(db, "notifications");
    const q = query(notificationsRef, where("status", "==", "pending"));
    const pendingSnap = await getDocs(q);

    for (const notifDoc of pendingSnap.docs) {
      const notif = notifDoc.data();

      try {
        // Enviar notificação via API interna
        const response = await fetch(`${process.env.NEXT_PUBLIC_BASE_URL || ''}/api/send-notification`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            type: notif.type,
            rifaId: notif.rifaId,
            rifaNome: notif.rifaNome,
            userId: notif.userId,
            email: notif.email,
            phone: notif.phone,
            winningNumber: notif.winningNumber,
            premio: notif.premio,
            tokens: notif.tokens,
            allParticipantTokens: notif.allParticipantTokens,
          }),
        });

        if (response.ok) {
          const notifRef = doc(db, "notifications", notifDoc.id);
          await updateDoc(notifRef, {
            status: "sent",
            sentAt: serverTimestamp(),
          });
          sent++;
        } else {
          throw new Error(`HTTP ${response.status}`);
        }
      } catch (e) {
        console.error(`Erro ao enviar notificação ${notifDoc.id}:`, e);
        const notifRef = doc(db, "notifications", notifDoc.id);
        await updateDoc(notifRef, {
          status: "error",
          error: String(e),
          lastAttempt: serverTimestamp(),
        });
        errors++;
      }
    }
  } catch (err) {
    console.error("Erro ao processar notificações pendentes:", err);
  }

  return { sent, errors };
}
